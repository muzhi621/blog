---
title: 最优化方法及其应用
tags: 
  - 最优化
  - matlab
  - 课程
  - 论文
categories: '论文'
abbrlink: 3b4c1ddc
date: 2019-03-06 12:30:25
copyright:
---

## 引言

在社会生产以及日常生活中，尤其是经济活动中，通常情况下，做一个决策对策备选方案往往不止一个，则自然你希望所选方案为最佳的，而最优化方法就是从众多可能的方案中选择一个可以达到最优目标的科学，是一门新兴的数学分支。因而最优化方法和最优化理论日趋受到重视，其在社会生活生产中已经渗透到社会中方方面面，包括经济，军事，管理等领域。而伴随着计算机科学的发展，解决最优化方法的工具也日趋完善，MATLAB就是其中最具代表性的最优化工具之一。

## 1.  提出问题

​	某商店拟制定某种商品 7-12月的进货，售货计划，已知商品仓库的最大容量为1500件，6月底已存货300件，年底库存不少于300件为宜，以后每个月初进货一次，假设各月份该商品买进，售出单价如下表，若每月的库存费为0.5元，问各月进货，售货各为多少件时，才能使收益最多，试建立数学模型并求解。

表1

| 月份          | 7    | 8    | 9    | 10   | 11   | 12   |
| ------------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 买进（元/件） | 28   | 26   | 25   | 27   | 24   | 23.5 |
| 售出（元/件） | 29   | 27   | 26   | 28   | 25   | 25   |

 

**问题来源：**AllExperiments__《数学建模实验》上机实验作业—张勇 

实验二 优化模型实验 题目3

https://wenku.baidu.com/view/8f56f49dbed5b9f3f90f1cec.html

 

## 2.  分析问题

​	此问题提出主要解决实际问题中的线性规划中的销售计划问题，在实际生产生活中经常会涉及的一个问题。为使得利润最大化，商人不得不通过合理的买进售出的规划，同时在考虑影响不可消除的成本下，通过合理的规划销售方案使得商品的销售计划达到利润的最大化。解决此类问题主要是通过分析问题，提炼出线性规划模型，然后利用MATLAB工具箱中的linprog函数解决。

```
MATLAB****中线性规划标准型：**

Min fTx

S.t. Ax<=0

Aeq·x=beq

Lb<=x<=ub
```

**linprog****函数：**

linprog函数主要用来求解现行规划问题，主要使用方法如下：

注意：

l  目标函数f要写成列矩阵的形式

l  约束要写成<= 的形式

l  函数是为求最小值设置的

调用格式：

x=linprog(f,A,b,Aeq,beq); 求解问题min f*x，约束条件为A*x<=b。

x=linprog(f,A,b,Aeq,beq,lb,ub); 求解上面的问题，但增加等式约束，即Aeq*x=beq。若没有不等式存在，则令A=[ ],b=[ ]。

x=linprog(f,A,b,Aeq,beq,lb,ub,x0); 设置初值为x0.该选项只使用于中型问题，默认时，算法将忽略初值。

x=linprog(f,A,b,Aeq,beq,lb,ub,x0,options); 用options指定的优化参数进行最小化。

[x,fval] = linprog(f,A,b,Aeq,beq,lb,ub)

[x,fval,exitflag,output，lambda]= linprog(f,A,b,Aeq,beq,lb,ub)

l  返回解x处的目标函数值fval。

l  返回exitflag值，描述函数计算的退出条件。

l  返回包含优化信息的输出变量output。

l  lambda参数是解x处的拉格朗日乘子。

其中：

Ø  x返回的是决策向量的取值；

Ø  fval返回的是目标函数的最优值;

Ø  f为价值向量（目标函数）;

Ø  A和b对应的是线性不等式约束;

Ø  Aeq和beq对应的是线性等式约束;

Ø  lb和ub分别对应决策的下界向量和上界向量;

 

**线性规划：**

​	现实问题求解最优化问题，就是在一定条件下达到利益最大化的目的。此问题集使得月利润最大，其中需考虑进货，仓储成本以及售出量所决定的利益，以此找到一个最优解使得例如能最大化。由题目问题可得，该问题属于线性规划问题，目标函数可是该商店的纯利润表达式，约束条件是现实问题中，对于利润最大化的限制，例如仓储容量，买进售出量，仓储成本。

还需考虑到问题是：

-  该商品在6-12月每个月中买进售出的价格不随时间变化。

- 每月月初计算库存费用为买进的商品量加上库存量。

- 不考虑除了仓储成本以及买进该商品的成本外其他影响最终利润的费用支出，诸如人力成本等。


## 3.  建立模型

根据线性规划的原理和方法，结合题目具体要求，构建适合的数学模型。

(1) 确定目标函数

设7-12月每个月的该商品的买进量和售出量如下表二所示

 

设7-12月实际买进售出

表2

| 月份 | 7    | 8    | 9    | 10   | 11   | 12   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 买进 | X11  | X12  | X13  | X14  | X15  | X16  |
| 售出 | X21  | X22  | X23  | X24  | X25  | X26  |

 

由题目可得，该商品6月底已存货量为300件，所以得出7-12月月初的库存量如下所示：

 

表3

| 月份   | 库存                                                |
| ------ | --------------------------------------------------- |
| 7      | 300+X11                                             |
| 8      | 300+X11-X21+X12                                     |
| 9      | 300+X11-X21+X12-X22+X13                             |
| 10     | 300+X11-X21+X12-X22+X13-X23+X14                     |
| 11     | 300+X11-X21+X12-X22+X13-X23+X14-X24+X15             |
| 12     | 300+X11-X21+X12-X22+X13-X23+X14-X24+X15-X25+X16     |
| 12月底 | 300+X11-X21+X12-X22+X13-X23+X14-X24+X15-X25+X16-X26 |

 

为使得该商品的利润达到做大化，利润可简化为：

​     利润=销售利润-仓储成本-买进成本
$$
目标函数：

Max F=29X21-28X11+27X22-26X12+26X23-25X13+28X24-27X14+25X25-

24X15+25X26-23.5X16-0.5(300+X11+300+X11-X21+X12+300+X11-X21+X12-X22+X13+300+X11-X21+X12-X22+X13-X23+X14+300+X11-X21+X12-X22+X13-X23+X14-X24+X15+300+X11-X21+X12-X22+X13-X23+X14-X24+X15)

化简Max F’=31.5X21-31X11+29X22-28.5X12+27.5X23-27X13+

29X24-28.5X14+25.5X25-25X15+25X26-24X16-900
$$


(2) 确定约束条件

约束条件 
$$
s.t.：

1)  商品仓库的最大容量为1500件

0<=300+X11<=1500

0<=300+X11-X21+X12<=1500

0<=300+X11-X21+X12-X22+X13<=1500

0<=300+X11-X21+X12-X22+X13-X23+X14<=1500

0<=300+X11-X21+X12-X22+X13-X23+X14-X24+X15<=1500

0<=300+X11-X21+X12-X22+X13-X23+X14-X24+X15-X25+X16<=1500

2)  年底库存不少于300件

300+X11-X21+X12-X22+X13-X23+X14-X24+X15-X25+X16-X26>=300

3)  买进和售出该商品不为负

X11 X21 …… X16 X26>=0
$$


(3) 建立线性规划模型
$$
Min C=31X11-31.5X21+28.5X12-29X22+27X13-27.5X23+

28.5X14-29X24+25X15-25.5X25+24X16-25X26+900
$$
构建解决模型：
$$
Min C’=31X11-31.5X21+28.5X12-29X22+27X13-27.5X23+

28.5X14-29X24+25X15-25.5X25+24X16-25X26

s.t.

X11<=1200

-X11+X21<=300

X11-X21+X12<=1200

-X11+X21-X12+X22<=300

X11-X21+X12-X22+X13<=1200

-X11+X21-X12+X22-X13+X23<=300

X11-X21+X12-X22+X13-X23+X14<=1200

-X11+X21-X12+X22-X13+X23-X14+X24<=300

X11-X21+X12-X22+X13-X23+X14-X24+X15<=1200

-X11+X21-X12+X22-X13+X23-X14+X24-X15+X25<=300

X11-X21+X12-X22+X13-X23+X14-X24+X15-X25+X16<=1200

-X11+X21-X12+X22-X13+X23-X14+X24-X15+X25-X16+X26<=0

-X11 -X21 …… -X16 -x26<=0
$$


## 4. 问题求解

采用调用工具箱法和修正单纯性函数法求解，见附录

求解可得：xm为：


$$
1200.00000000000

1500.00000000000

1499.99999999999

1500.00000000000

1500.00000000000

3.32426374296570e-12

5.04039389707337e-12

1500.00000000000

1500.00000000000

1499.99999999999

1500.00000000000

1200.00000000000
$$

$$
Fm=-8.549999999999593e+03

C’=fm=-8550

C=C’+900=-8550+900=-7650

利润：Max F=-C=7550
$$
所以7-12月该商品买进售出计划如下表

表4

| 月份       | 7    | 8    | 9    | 10   | 11   | 12   |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 买进（件） | 1200 | 1500 | 1500 | 0    | 1500 | 1500 |
| 售出（件） | 1500 | 1500 | 0    | 1500 | 1500 | 1200 |

所以该商店出售该商品最大的利润为7550元

 

## 5.  总结

​	学习本门最优化课程，收获颇多。在此之前，对于MATLAB这个软件从来都是只闻其名，不见其身，本以为计算机专业学生来使用MATLAB应该上手极快应是，但是结果并不是想象中的那样美好，不过当学习这软件后才发现软件的强大，可以解决许多问题，特别是对于图像图形的绘制，解决了很多，最优化问题归根到底还是数学问题，以前学习数学，基本是用不上的。

 

## 6.  附录

**调用工具箱法：**

```matlab
zuiyouhua.m**

f=[31,-31.5,28.5,-29,27,-27.5,28.5,-29,25,-25.5,24,-25];

A=[ 1 0 0 0 0 0 0 0 0 0 0 0;

​    -1 1 0 0 0 0 0 0 0 0 0 0;

​    1 -1 1 0 0 0 0 0 0 0 0 0;

​    -1 1 -1 1 0 0 0 0 0 0 0 0;

​    1 -1 1 -1 1 0 0 0 0 0 0 0;

​    -1 1 -1 1 -1 1 0 0 0 0 0 0;

​    1 -1 1 -1 1 -1 1 0 0 0 0 0;

​    -1 1 -1 1 -1 1 -1 1 0 0 0 0;

​    1 -1 1 -1 1 -1 1 -1 1 0 0 0;

​    -1 1 -1 1 -1 1 -1 1 -1 1 0 0;

​    1 -1 1 -1 1 -1 1 -1 1 -1 1 0;

​    -1 1 -1 1 -1 1 -1 1 -1 1 -1 1

​    ];
b=[1200;300;1200;300;1200;300;1200;300;1200;300;1200;0];

lb=[0 0 0 0 0 0 0 0 0 0 0 0];

[xm,fval,exitflag,output,lambda]=linprog(f,A,b,[],[],lb);
```





**单纯形函数法：**

```matlab
ModifSimpleMthd.m**

function  [x,minf] = ModifSimpleMthd(A,c,b,baseVector)

% A:约束矩阵

% c:目标函数系数矩阵

% b:约束右端向量

% baseVector:初始基向量

% x:目标函数取最小值时的自变量的值

% minf:目标函数最小值

 

sz = size(A);

nVia = sz(2);

n = sz(1);

xx = 1:nVia;

nobase = zeros(1,1);

m = 1;

 

if c>=0

​    vr = find(c~=0 ,1,'last');

​    rgv = inv(A(:,(nVia-n+1):nVia))*b;

​    if rgv >=0

​        x = zeros(1,vr);

​        minf = 0;

​    else

​        disp('不存在最优解!');

​        x = NaN;

​        minf = NaN;

​        return;

​    end

end

 

for i=1:nVia

​    if(isempty(find(baseVector == xx(i),1)))

​        nobase(m) = i;

​        m = m + 1;

​    else

​        

​    end

end

bCon = 1;

M = 0;

B = A(:,baseVector);

invB = inv(B);

 

while bCon

​    nB = A(:,nobase);

​    ncb = c(nobase);

​    B = A(:,baseVector);

​    cb = c(baseVector);

​    xb = invB*b;

​    f = cb*xb;

​    w = cb*invB;

 

​    for i=1:length(nobase)

​        sigma(i) = w*nB(:,i)-ncb(i);

​    end

​    [maxs,ind] = max(sigma);

​    if maxs <= 0

​        minf = cb*xb;

​        vr = find(c~=0 ,1,'last');

​        for l=1:vr

​            for t=1:length(baseVector)

​                if(baseVector(t)==l)

​                    x(l)=xb(t);

​                end

​            end

​        end

​        bCon = 0;

​    else

​        y = inv(B)*A(:,nobase(ind));

​        if y <= 0

​            disp('No solution!');

​        else

​            minb = inf;

​            chagB = 0;

​            for j=1:length(y)

​                if y(j)>0

​                    bz = xb(j)/y(j);

​                    if bz<minb

​                        minb = bz;

​                        chagB = j;

​                    end

​                end

​            end

​            tmp = baseVector(chagB);

​            baseVector(chagB) = nobase(ind);

​            nobase(ind) = tmp;

​              

​            for j=1:chagB-1

​                if y(j) ~=0

​                    invB(j,:) = invB(j,:) - invB(chagB,:)*y(j)/y(chagB);

​                end

​            end

​            for j=chagB+1:length(y)

​                if y(j) ~=0

​                    invB(j,:) = invB(j,:) - invB(chagB,:)*y(j)/y(chagB);

​                end

​            end

​            invB(chagB,:) =invB(chagB,:)/y(chagB);

​        end

​    end

​    M = M + 1;

​    if (M == 1000000)

​        disp('找不到最优解');

​        x = NaN;

​        minf = NaN;

​        return;

​    end

end

 
```



```matlab
 **main.m**

c=[31,-31.5,28.5,-29,27,-27.5,29.5,-29,25,-25.5,24,-25,0,0,0,0,0,0,0,0,0,0,0,0];

A=[ 1 0 0 0 0 0 0 0 0 0 0 0,1,0,0,0,0,0,0,0,0,0,0,0;

​    -1 1 0 0 0 0 0 0 0 0 0 0,0,1,0,0,0,0,0,0,0,0,0,0;

​    1 -1 1 0 0 0 0 0 0 0 0 0,0,0,1,0,0,0,0,0,0,0,0,0;

​    -1 1 -1 1 0 0 0 0 0 0 0 0,0,0,0,1,0,0,0,0,0,0,0,0;

​    1 -1 1 -1 1 0 0 0 0 0 0 0, 0,0,0,0,1,0,0,0,0,0,0,0;

​    -1 1 -1 1 -1 1 0 0 0 0 0 0,0,0,0,0,0,1,0,0,0,0,0,0;

​    1 -1 1 -1 1 -1 1 0 0 0 0 0,0,0,0,0,0,0,1,0,0,0,0,0;

​    -1 1 -1 1 -1 1 -1 1 0 0 0 0,0,0,0,0,0,0,0,1,0,0,0,0;

​    1 -1 1 -1 1 -1 1 -1 1 0 0 0,0,0,0,0,0,0,0,0,1,0,0,0;

​    -1 1 -1 1 -1 1 -1 1 -1 1 0 0,0,0,0,0,0,0,0,0,0,1,0,0;

​    1 -1 1 -1 1 -1 1 -1 1 -1 1 0,0,0,0,0,0,0,0,0,0,0,1,0;

​    -1 1 -1 1 -1 1 -1 1 -1 1 -1 1,0,0,0,0,0,0,0,0,0,0,0,1

​    ];

b=[1200;300;1200;300;1200;300;1200;300;1200;300;1200;0];

 [x,minf] = ModifSimpleMthd(A,c,b,[13 14 15 16 17 18 19 20 21 22 23 24]);


```

